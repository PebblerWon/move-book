# 整数类型

Move 语言支持六种无符号整数类型：`u8`、`u16`、`u32`、`u64`、`u128` 和 `u256`。这些类型的值范围从 0 到根据类型大小决定的最大值。

| 类型                        | 值范围                         |
| --------------------------- | ------------------------------ |
| 无符号 8 位整数，`u8`       | 0 到 2<sup>8</sup> - 1         |
| 无符号 16 位整数，`u16`     | 0 到 2<sup>16</sup> - 1        |
| 无符号 32 位整数，`u32`     | 0 到 2<sup>32</sup> - 1        |
| 无符号 64 位整数，`u64`     | 0 到 2<sup>64</sup> - 1        |
| 无符号 128 位整数，`u128`   | 0 到 2<sup>128</sup> - 1       |
| 无符号 256 位整数，`u256`   | 0 到 2<sup>256</sup> - 1       |

## 字面值

这些类型的字面值可以用数字序列表示（例如 `112`）或十六进制表示（例如 `0xFF`）。可以选择性地在字面值后加上类型后缀（例如 `112u8`）。如果未指定类型，编译器会尝试从字面值所在的上下文推断类型。如果无法推断，则默认假设为 `u64`。

数字字面值可以用下划线分隔以增强可读性（例如 `1_234_5678`、`1_000u128`、`0xAB_CD_12_35`）。

如果字面值超出了指定（或推断）类型的范围，会报告错误。

### 示例

```move
// 带显式注释的字面值
let explicit_u8 = 1u8;
let explicit_u16 = 1u16;
let explicit_u32 = 1u32;
let explicit_u64 = 2u64;
let explicit_u128 = 3u128;
let explicit_u256 = 1u256;
let explicit_u64_underscored = 154_322_973u64;

// 简单推断的字面值
let simple_u8: u8 = 1;
let simple_u16: u16 = 1;
let simple_u32: u32 = 1;
let simple_u64: u64 = 2;
let simple_u128: u128 = 3;
let simple_u256: u256 = 1;

// 复杂推断的字面值
let complex_u8 = 1; // 推断为 u8
// 右侧的移位参数必须是 u8
let _unused = 10 << complex_u8;

let x: u8 = 38;
let complex_u8 = 2; // 推断为 u8
// `+` 的参数必须是相同类型
let _unused = x + complex_u8;

let complex_u128 = 133_876; // 推断为 u128
// 从函数参数类型推断
function_that_takes_u128(complex_u128);

// 字面值可以用十六进制表示
let hex_u8: u8 = 0x1;
let hex_u16: u16 = 0x1BAE;
let hex_u32: u32 = 0xDEAD80;
let hex_u64: u64 = 0xCAFE;
let hex_u128: u128 = 0xDEADBEEF;
let hex_u256: u256 = 0x1123_456A_BCDE_F;
```

## 操作

### 算术运算

每种整数类型都支持相同的检查算术运算。对于所有这些运算，两个操作数（左侧和右侧操作数）_必须_ 是相同类型。如果需要对不同类型的值进行操作，必须先进行[类型转换](#casting)。同样，如果预期运算结果会超出整数类型的范围，需在运算前进行[类型转换](#casting)到更大类型。

所有算术运算在发生溢出、下溢或除以零等数学错误时会中止。

| 语法 | 操作      | 中止条件                      |
| ---- | --------- | ----------------------------- |
| `+`  | 加法      | 结果超出整数类型的最大范围    |
| `-`  | 减法      | 结果小于零                    |
| `*`  | 乘法      | 结果超出整数类型的最大范围    |
| `%`  | 模除法    | 除数为 `0`                    |
| `/`  | 截断除法  | 除数为 `0`                    |

### 位运算

整数类型支持以下位运算，这些运算将每个数字视为一系列的 0 或 1 位，而不是数值。

位运算不会中止。

| 语法                | 操作          | 描述                             |
| ------------------- | ------------- | -------------------------------- |
| `&`                 | 位与          | 对每个位进行逐位的布尔与运算    |
| <code>&#124;</code> | 位或          | 对每个位进行逐位的布尔或运算    |
| `^`                 | 位异或        | 对每个位进行逐位的布尔异或运算  |

### 位移运算

与位运算类似，每种整数类型支持位移运算。但与其他运算不同，右侧操作数（要移位的位数）必须 _始终_ 为 `u8` 类型，不必与左侧操作数（要移位的数字）类型匹配。

如果移位位数大于或等于 `8`、`16`、`32`、`64`、`128` 或 `256`（对于 `u8`、`u16`、`u32`、`u64`、`u128` 和 `u256`），位移运算会中止。

| 语法 | 操作       | 中止条件                                                |
| ---- | ---------- | ------------------------------------------------------- |
| `<<` | 左移       | 移位位数大于整数类型的位数                              |
| `>>` | 右移       | 移位位数大于整数类型的位数                              |

### 比较运算

整数类型是 Move 语言中唯一可以使用比较运算符的类型。两个操作数需要是相同类型。如果需要比较不同类型的整数，必须先进行[类型转换](#casting)。

比较运算不会中止。

| 语法 | 操作       |
| ---- | ---------- |
| `<`  | 小于       |
| `>`  | 大于       |
| `<=` | 小于等于   |
| `>=` | 大于等于   |

### 相等运算

与所有具有 [`drop`](../abilities.md) 能力的类型一样，所有整数类型都支持 ["相等"](../equality.md) 和 ["不相等"](../equality.md) 运算。两个操作数需要是相同类型。如果需要比较不同类型的整数，必须先进行[类型转换](#casting)。

相等运算不会中止。

| 语法 | 操作 |
| ---- | ---- |
| `==` | 相等 |
| `!=` | 不相等 |

更多细节请参见[相等](../equality.md)部分。

## 类型转换

一种整数类型可以转换为另一种整数类型。整数是 Move 语言中唯一支持类型转换的类型。

类型转换 _不会_ 截断。如果结果超出指定类型的范围，转换会中止。

| 语法       | 操作                           | 中止条件                      |
| ---------- | ----------------------------- | ----------------------------- |
| `(e as T)` | 将整数表达式 `e` 转换为整数类型 `T` | `e` 超出 `T` 的表示范围       |

在这里，`e` 的类型必须是 `8`、`16`、`32`、`64`、`128` 或 `256`，`T` 必须是 `u8`、`u16`、`u32`、`u64`、`u128` 或 `u256`。

例如：

- `(x as u8)`
- `(y as u16)`
- `(873u16 as u32)`
- `(2u8 as u64)`
- `(1 + 3 as u128)`
- `(4/2 + 12345 as u256)`

## 所有权

与语言中其他标量值一样，整数值是隐式可复制的，这意味着它们可以在不需要显式指令（如 [`copy`](../variables.md#move-and-copy)）的情况下进行复制。